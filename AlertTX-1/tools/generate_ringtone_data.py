#!/usr/bin/env python3
"""
RTTTL Data Generator for Alert TX-1

This script scans the data/ringtones/ directory and generates a C++ header file
containing all RTTTL ringtone data as both text and binary formats. The binary
format is 50-70% smaller than text RTTTL, providing significant memory savings.

Usage:
    python3 tools/generate_ringtone_data.py

Output:
    src/ringtones/ringtone_data.h - Generated header file with embedded RTTTL data
"""

import os
import re
import sys
from pathlib import Path

def sanitize_name(filename):
    """Convert filename to valid C++ identifier"""
    # Remove extension and replace non-alphanumeric chars with underscore
    name = re.sub(r'[^a-zA-Z0-9_]', '_', filename.replace('.txt', '').replace('.rtttl.txt', ''))
    # Ensure it starts with a letter
    if name and name[0].isdigit():
        name = 'ringtone_' + name
    return name

def extract_rtttl_name(content):
    """Extract the RTTTL name from the content (before the first colon)"""
    if ':' in content:
        return content.split(':')[0].strip()
    return "Unknown"

def parse_rtttl_to_binary(rtttl_text):
    """
    Parse RTTTL text and convert to binary format (10-bit)
    Based on AnyRtttl library binary format specification
    """
    if not rtttl_text or ':' not in rtttl_text:
        return None
    
    # Split into sections
    parts = rtttl_text.split(':', 2)
    if len(parts) < 3:
        return None
    
    name = parts[0]
    defaults = parts[1]
    notes = parts[2]
    
    # Parse defaults
    default_duration = 4
    default_octave = 5
    default_bpm = 160
    
    for default in defaults.split(','):
        if 'd=' in default:
            default_duration = int(default.split('=')[1])
        elif 'o=' in default:
            default_octave = int(default.split('=')[1])
        elif 'b=' in default:
            default_bpm = int(default.split('=')[1])
    
    # Convert to binary format
    binary_data = []
    
    # Header: song name (11 bytes) + default values (2 bytes)
    # Song name (padded to 11 bytes)
    name_bytes = name.encode('ascii')[:11].ljust(11, b'\0')
    binary_data.extend(name_bytes)
    
    # Default values (duration, octave, BPM)
    # Duration index: 1->0, 2->1, 4->2, 8->3, 16->4, 32->5
    duration_map = {1: 0, 2: 1, 4: 2, 8: 3, 16: 4, 32: 5}
    duration_idx = duration_map.get(default_duration, 2)
    
    # Octave index: 4->0, 5->1, 6->2, 7->3
    octave_idx = max(0, min(3, default_octave - 4))
    
    # BPM index: map to predefined BPM values
    bpm_values = [25, 28, 31, 35, 40, 45, 50, 56, 63, 70, 80, 90, 100, 112, 125, 140, 160, 180, 200, 225, 250, 285, 320, 355, 400, 450, 500, 565, 635, 715, 800, 900]
    bpm_idx = 16  # Default to 160 BPM
    for i, bpm in enumerate(bpm_values):
        if bpm >= default_bpm:
            bpm_idx = i
            break
    
    # Pack default values into 2 bytes
    default_byte1 = (duration_idx & 0x07) | ((octave_idx & 0x03) << 3)
    default_byte2 = bpm_idx & 0x1F
    binary_data.extend([default_byte1, default_byte2])
    
    # Parse notes
    note_letters = {'c': 0, 'd': 1, 'e': 2, 'f': 3, 'g': 4, 'a': 5, 'b': 6, 'p': 7}
    
    for note in notes.split(','):
        note = note.strip()
        if not note:
            continue
        
        # Parse note components
        duration = default_duration
        note_letter = 'p'
        octave = default_octave
        is_sharp = False
        is_dotted = False
        
        # Extract duration
        duration_match = re.match(r'(\d+)', note)
        if duration_match:
            duration = int(duration_match.group(1))
            note = note[len(duration_match.group(1)):]
        
        # Extract note letter
        if note and note[0].lower() in note_letters:
            note_letter = note[0].lower()
            note = note[1:]
        
        # Extract sharp
        if note.startswith('#'):
            is_sharp = True
            note = note[1:]
        
        # Extract octave
        octave_match = re.match(r'(\d+)', note)
        if octave_match:
            octave = int(octave_match.group(1))
            note = note[len(octave_match.group(1)):]
        
        # Check for dotted
        if note.startswith('.'):
            is_dotted = True
        
        # Pack note into 2 bytes (10-bit format)
        duration_idx = duration_map.get(duration, 2)
        note_idx = note_letters.get(note_letter, 7)
        octave_idx = max(0, min(3, octave - 4))
        
        note_byte1 = (duration_idx & 0x07) | ((note_idx & 0x07) << 3) | (is_sharp << 6) | (is_dotted << 7)
        note_byte2 = (octave_idx & 0x03)
        
        binary_data.extend([note_byte1, note_byte2])
    
    return binary_data

def generate_header_file(ringtone_files):
    """Generate the C++ header file with embedded RTTTL data"""
    
    header_content = f"""// Auto-generated by tools/generate_ringtone_data.py
// Do not edit this file manually - it will be overwritten!

#ifndef RINGTONE_DATA_H
#define RINGTONE_DATA_H

#include <Arduino.h>

// RTTTL ringtone data - embedded at compile time (binary format only)
// Generated from {len(ringtone_files)} files in data/ringtones/
// Binary format provides 50-70% memory savings over text RTTTL

"""
    
    # Add ringtone data arrays (binary format only)
    ringtone_names = []
    for filename, content, rtttl_name in ringtone_files:
        cpp_name = sanitize_name(filename)
        ringtone_names.append((cpp_name, rtttl_name))
        
        # Generate binary data
        binary_data = parse_rtttl_to_binary(content)
        
        header_content += f"""// {rtttl_name} - from {filename}
"""
        
        if binary_data:
            # Convert binary data to C++ array
            binary_array = ', '.join([f'0x{b:02X}' for b in binary_data])
            header_content += f"""const unsigned char {cpp_name}[] = {{{binary_array}}};
const int {cpp_name}_length = {len(binary_data)};
"""
        else:
            header_content += f"""// Binary conversion failed for {rtttl_name}
const unsigned char* {cpp_name} = nullptr;
const int {cpp_name}_length = 0;
"""
        
        header_content += "\n"
    
    # Add ringtone registry
    header_content += f"""
// Ringtone registry - maps names to binary data
struct RingtoneEntry {{
    const char* name;
    const unsigned char* data;
    int length;
    const char* filename;
}};

static const RingtoneEntry RINGTONE_REGISTRY[] = {{
"""
    
    for cpp_name, rtttl_name in ringtone_names:
        header_content += f'    {{"{rtttl_name}", {cpp_name}, {cpp_name}_length, "{cpp_name}"}},\n'
    
    header_content += f"""    {{nullptr, nullptr, 0, nullptr}}  // End marker
}};

// Total number of ringtones
static const int RINGTONE_COUNT = {len(ringtone_files)};

// Helper functions
inline const unsigned char* getRingtoneData(const char* name) {{
    for (int i = 0; i < RINGTONE_COUNT; i++) {{
        if (strcmp(RINGTONE_REGISTRY[i].name, name) == 0) {{
            return RINGTONE_REGISTRY[i].data;
        }}
    }}
    return nullptr;
}}

inline const unsigned char* getRingtoneData(int index) {{
    if (index >= 0 && index < RINGTONE_COUNT) {{
        return RINGTONE_REGISTRY[index].data;
    }}
    return nullptr;
}}

inline int getRingtoneLength(const char* name) {{
    for (int i = 0; i < RINGTONE_COUNT; i++) {{
        if (strcmp(RINGTONE_REGISTRY[i].name, name) == 0) {{
            return RINGTONE_REGISTRY[i].length;
        }}
    }}
    return 0;
}}

inline int getRingtoneLength(int index) {{
    if (index >= 0 && index < RINGTONE_COUNT) {{
        return RINGTONE_REGISTRY[index].length;
    }}
    return 0;
}}

inline const char* getRingtoneName(int index) {{
    if (index >= 0 && index < RINGTONE_COUNT) {{
        return RINGTONE_REGISTRY[index].name;
    }}
    return nullptr;
}}

inline int findRingtoneIndex(const char* name) {{
    for (int i = 0; i < RINGTONE_COUNT; i++) {{
        if (strcmp(RINGTONE_REGISTRY[i].name, name) == 0) {{
            return i;
        }}
    }}
    return -1;
}}

#endif // RINGTONE_DATA_H
"""
    
    return header_content

def main():
    """Main function to generate ringtone data header"""
    
    # Get project root directory
    script_dir = Path(__file__).parent
    project_root = script_dir.parent
    ringtone_dir = project_root / "data" / "ringtones"
    output_file = project_root / "src" / "ringtones" / "ringtone_data.h"
    
    print(f"Scanning for RTTTL files in: {ringtone_dir}")
    
    # Check if ringtone directory exists
    if not ringtone_dir.exists():
        print(f"Error: Ringtones directory not found: {ringtone_dir}")
        sys.exit(1)
    
    # Find all RTTTL files
    ringtone_files = []
    for file_path in ringtone_dir.glob("*.rtttl.txt"):
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().strip()
                if content:
                    rtttl_name = extract_rtttl_name(content)
                    ringtone_files.append((file_path.name, content, rtttl_name))
                    print(f"  Found: {file_path.name} -> {rtttl_name}")
        except Exception as e:
            print(f"  Warning: Could not read {file_path}: {e}")
    
    if not ringtone_files:
        print("Error: No RTTTL files found!")
        sys.exit(1)
    
    print(f"\nFound {len(ringtone_files)} ringtone files")
    
    # Generate header file
    header_content = generate_header_file(ringtone_files)
    
    # Ensure output directory exists
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Write header file
    try:
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(header_content)
        print(f"\nGenerated: {output_file}")
        print(f"Total ringtones: {len(ringtone_files)}")
        print("\nRingtones included:")
        for _, _, rtttl_name in ringtone_files:
            print(f"  - {rtttl_name}")
        
        # Show memory savings
        total_text_size = sum(len(content) for _, content, _ in ringtone_files)
        total_binary_size = sum(len(parse_rtttl_to_binary(content) or []) for _, content, _ in ringtone_files)
        savings = ((total_text_size - total_binary_size) / total_text_size) * 100 if total_text_size > 0 else 0
        
        print(f"\n📊 Memory Analysis:")
        print(f"  Text format: {total_text_size} bytes")
        print(f"  Binary format: {total_binary_size} bytes")
        print(f"  Memory savings: {savings:.1f}%")
        print(f"  Using binary format only for maximum efficiency")
        
    except Exception as e:
        print(f"Error writing output file: {e}")
        sys.exit(1)
    
    print("\n✅ RTTTL data generation complete!")
    print("\nNext steps:")
    print("1. Include 'ringtone_data.h' in your RingtonePlayer class")
    print("2. Use getRingtoneData() to access binary ringtone data")
    print("3. Binary format provides significant memory savings")
    print("4. Re-run this script whenever you add new RTTTL files")

if __name__ == "__main__":
    main() 